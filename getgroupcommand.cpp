/*
 *  getgroupcommand.cpp
 *  Mothur
 *
 *  Created by Thomas Ryabin on 2/2/09.
 *  Copyright 2009 Schloss Lab UMASS Amherst. All rights reserved.
 *
 */

#include "getgroupcommand.h"

//**********************************************************************************************************************
GetgroupCommand::GetgroupCommand(string option){
	try {
		globaldata = GlobalData::getInstance();
		abort = false;
		
		//allow user to run help
		if(option == "help") { help(); abort = true; }
		
		else {
			//valid paramters for this command
			string Array[] =  {"outputdir","inputdir"};
			vector<string> myArray (Array, Array+(sizeof(Array)/sizeof(string)));
			
			OptionParser parser(option);
			map<string,string> parameters = parser.getParameters();
			
			ValidParameters validParameter;
			//check to make sure all parameters are valid for command
			for (map<string,string>::iterator it = parameters.begin(); it != parameters.end(); it++) { 
				if (validParameter.isValidParameter(it->first, myArray, it->second) != true) {  abort = true;  }
			}
			
			//if the user changes the output directory command factory will send this info to us in the output parameter 
			string outputDir = validParameter.validFile(parameters, "outputdir", false);		if (outputDir == "not found"){	outputDir = "";		}
			
			if ((globaldata->getSharedFile() == "")) { mothurOut("You must use the read.otu command to read a groupfile or a sharedfile before you can use the get.group command."); mothurOutEndLine(); abort = true; }
				
			if (abort == false) {
				//open shared file
				sharedfile = globaldata->getSharedFile();
				openInputFile(sharedfile, in);
		
				//open output file
				if (outputDir == "") { outputDir += hasPath(sharedfile); }
				outputFile = outputDir + getRootName(getSimpleName(sharedfile)) + "bootGroups";
				openOutputFile(outputFile, out);

			}
		}
	}
	catch(exception& e) {
		errorOut(e, "GetgroupCommand", "GetgroupCommand");
		exit(1);
	}
}
//**********************************************************************************************************************

void GetgroupCommand::help(){
	try {
		mothurOut("The get.group command can only be executed after a successful read.otu command.\n");
		//mothurOut("The get.group command outputs a .bootGroups file to you can use in addition to the tree file generated by the bootstrap.shared command to run the consensus command.\n");
		mothurOut("You may not use any parameters with the get.group command.\n");
		mothurOut("The get.group command should be in the following format: \n");
		mothurOut("get.group()\n");
		mothurOut("Example get.group().\n");
		
	}
	catch(exception& e) {
		errorOut(e, "GetgroupCommand", "help");
		exit(1);
	}
}

//**********************************************************************************************************************

GetgroupCommand::~GetgroupCommand(){
}

//**********************************************************************************************************************

int GetgroupCommand::execute(){
	try {
	
		if (abort == true) { return 0; }
	
		int num, inputData, count;
		count = 0;  
		string holdLabel, nextLabel, groupN, label;
		
		//read in first row since you know there is at least 1 group.
		in >> label >> groupN >> num;
		holdLabel = label;
		
		//output first group
		mothurOut(groupN); mothurOutEndLine();
		out << groupN << '\t' << groupN << endl;	
			
		//get rest of line
		for(int i=0;i<num;i++){
			in >> inputData;
		}
		
		if (in.eof() != true) { in >> nextLabel; }
		
		//read the rest of the groups info in
		while ((nextLabel == holdLabel) && (in.eof() != true)) {
			in >> groupN >> num;
			count++;
			
			//output next group
			mothurOut(groupN); mothurOutEndLine();
			out << groupN << '\t' << groupN << endl;				
			
			//fill vector.  
			for(int i=0;i<num;i++){
				in >> inputData;
			}
			
			if (in.eof() != true) { in >> nextLabel; }
		}
		
		in.close();
		out.close();
		return 0;	
	}

	catch(exception& e) {
		errorOut(e, "GetgroupCommand", "execute");
		exit(1);
	}
}


